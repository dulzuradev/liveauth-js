{"version":3,"sources":["../src/pow.worker.ts"],"sourcesContent":["export interface PowWorkerMessage {\n    projectPublicKey: string;\n    challengeHex: string;\n    targetHex: string;\n    maxIterations?: number;\n    progressInterval?: number;\n}\n\nexport interface PowWorkerResult {\n    type: 'solution' | 'progress' | 'timeout';\n    nonce?: number;\n    hashHex?: string;\n    iterations?: number;\n    hashesPerSec?: number;\n}\n\nself.onmessage = async (e: MessageEvent<PowWorkerMessage>) => {\n    const { \n        projectPublicKey, \n        challengeHex, \n        targetHex, \n        maxIterations = 50_000_000,\n        progressInterval = 10_000\n    } = e.data;\n\n    let nonce = 0;\n    const startTime = performance.now();\n    let lastProgressTime = startTime;\n\n    while (nonce < maxIterations) {\n        const input = `${projectPublicKey}:${challengeHex}:${nonce}`;\n        const hash = await sha256Hex(input);\n\n        if (hash <= targetHex) {\n            const elapsed = performance.now() - startTime;\n            postMessage({ \n                type: 'solution', \n                nonce, \n                hashHex: hash,\n                iterations: nonce + 1,\n                hashesPerSec: Math.round((nonce + 1) / (elapsed / 1000))\n            } satisfies PowWorkerResult);\n            return;\n        }\n\n        nonce++;\n\n        // Send progress updates periodically\n        if (nonce % progressInterval === 0) {\n            const now = performance.now();\n            const elapsed = now - startTime;\n            const recentElapsed = now - lastProgressTime;\n            \n            postMessage({ \n                type: 'progress', \n                iterations: nonce,\n                hashesPerSec: Math.round(progressInterval / (recentElapsed / 1000))\n            } satisfies PowWorkerResult);\n            \n            lastProgressTime = now;\n        }\n    }\n\n    // Hit max iterations without solution\n    postMessage({ \n        type: 'timeout', \n        iterations: nonce \n    } satisfies PowWorkerResult);\n};\n\nasync function sha256Hex(input: string): Promise<string> {\n    const buf = await crypto.subtle.digest(\n        'SHA-256',\n        new TextEncoder().encode(input)\n    );\n\n    return [...new Uint8Array(buf)]\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n"],"mappings":";AAgBA,KAAK,YAAY,OAAO,MAAsC;AAC1D,QAAM;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,EACvB,IAAI,EAAE;AAEN,MAAI,QAAQ;AACZ,QAAM,YAAY,YAAY,IAAI;AAClC,MAAI,mBAAmB;AAEvB,SAAO,QAAQ,eAAe;AAC1B,UAAM,QAAQ,GAAG,gBAAgB,IAAI,YAAY,IAAI,KAAK;AAC1D,UAAM,OAAO,MAAM,UAAU,KAAK;AAElC,QAAI,QAAQ,WAAW;AACnB,YAAM,UAAU,YAAY,IAAI,IAAI;AACpC,kBAAY;AAAA,QACR,MAAM;AAAA,QACN;AAAA,QACA,SAAS;AAAA,QACT,YAAY,QAAQ;AAAA,QACpB,cAAc,KAAK,OAAO,QAAQ,MAAM,UAAU,IAAK;AAAA,MAC3D,CAA2B;AAC3B;AAAA,IACJ;AAEA;AAGA,QAAI,QAAQ,qBAAqB,GAAG;AAChC,YAAM,MAAM,YAAY,IAAI;AAC5B,YAAM,UAAU,MAAM;AACtB,YAAM,gBAAgB,MAAM;AAE5B,kBAAY;AAAA,QACR,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,cAAc,KAAK,MAAM,oBAAoB,gBAAgB,IAAK;AAAA,MACtE,CAA2B;AAE3B,yBAAmB;AAAA,IACvB;AAAA,EACJ;AAGA,cAAY;AAAA,IACR,MAAM;AAAA,IACN,YAAY;AAAA,EAChB,CAA2B;AAC/B;AAEA,eAAe,UAAU,OAAgC;AACrD,QAAM,MAAM,MAAM,OAAO,OAAO;AAAA,IAC5B;AAAA,IACA,IAAI,YAAY,EAAE,OAAO,KAAK;AAAA,EAClC;AAEA,SAAO,CAAC,GAAG,IAAI,WAAW,GAAG,CAAC,EACzB,IAAI,OAAK,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EACxC,KAAK,EAAE;AAChB;","names":[]}